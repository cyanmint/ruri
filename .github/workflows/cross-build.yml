name: Cross-compile release

on:
  workflow_dispatch:
  push:
    branches: [ "main" ]
    paths:
      - 'src/**'
      - 'build/**'
      - 'build.c'
      - '.github/**'
    tags:
      - "v*"
  pull_request:

jobs:
  update:
    name: Fetch Latest Version
    runs-on: ubuntu-latest
    outputs:
      release: ${{ steps.fetch_version.outputs.release }}
      version: ${{ steps.fetch_version.outputs.version }}
      release_name: ${{ steps.fetch_version.outputs.release_name }}
      build_time: ${{ steps.fetch_version.outputs.build_time }}
    steps:
      - name: fetch latest version
        id: fetch_version
        run: |
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref_type }}" == "tag" ]]; then
            version="${{ github.ref_name }}"
            release_name="ruri ${{ github.ref_name }} Release"
          else
            response=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -L "https://api.github.com/repos/${{ github.repository }}/releases/latest")
            version=$(echo "$response" | jq -r .tag_name)
            release_name=$(echo "$response" | jq -r .name)
          fi

          if [[ -n "$version" && "$version" != "null" && -n "$release_name" && "$release_name" != "null" ]]; then
            echo "release=true" >> $GITHUB_OUTPUT
          else
            echo "release=false" >> $GITHUB_OUTPUT
          fi

          build_time="UTC $(TZ=UTC date '+%Y%m%d%H%M')"
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "release_name=$release_name" >> $GITHUB_OUTPUT
          echo "build_time=$build_time" >> $GITHUB_OUTPUT

  cross-build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    strategy:
      fail-fast: false  # Don't cancel other jobs on failure - we want to see all results
      matrix:
        include:
          - arch: x86_64
            zig_target: x86_64-linux-musl
          - arch: x86
            zig_target: x86-linux-musl
          - arch: aarch64
            zig_target: aarch64-linux-musl
          - arch: armv7
            zig_target: arm-linux-musleabihf
          - arch: ppc64le
            zig_target: powerpc64le-linux-musl
          - arch: riscv64
            zig_target: riscv64-linux-musl
          - arch: s390x
            zig_target: s390x-linux-musl
    env:
      ARCHITECTURE: ${{ matrix.arch }}
      ZIG_TARGET: ${{ matrix.zig_target }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Zig for cross-compilation
        run: |
          set -e
          # Download and install Zig (has built-in cross-compilation support)
          wget -q https://ziglang.org/download/0.11.0/zig-linux-x86_64-0.11.0.tar.xz
          tar -xf zig-linux-x86_64-0.11.0.tar.xz
          sudo mv zig-linux-x86_64-0.11.0 /opt/zig
          echo "/opt/zig" >> $GITHUB_PATH
          
          # Install other dependencies
          sudo apt-get update
          sudo apt-get install -y upx-ucl

      - name: Cross-compile static binary for ${{ matrix.arch }}
        shell: bash
        run: |
          export PATH="/opt/zig:$PATH"
          
          # Zig can be used as a drop-in replacement for gcc/clang with cross-compilation
          export CC="zig cc -target $ZIG_TARGET"
          export AR="zig ar"
          export RANLIB="zig ranlib"
          
          # Verify zig is available
          zig version

          # Create output directories
          mkdir -p output output2 output3

          # Build fakepid library (static)
          cd src/fakepid
          make clean
          CC="zig cc -target $ZIG_TARGET" make
          cd ../..

          # Build ruri (static)
          zig cc -target $ZIG_TARGET build.c -o build-ruri
          ./build-ruri -s -f

          cp ruri output/ruri
          cp LICENSE output/LICENSE

          cp ruri output2/ruri
          cp LICENSE output2/LICENSE

          ./build-ruri -s -c -f
          cp ruri output3/ruri
          cp LICENSE output3/LICENSE
          
          # Verify binaries
          file output/ruri
          
          # UPX compression for supported architectures
          case "$ARCHITECTURE" in
            x86_64|x86|aarch64|ppc64le)
              upx --best output2/ruri || true
              upx --best output3/ruri || true
              ;;
          esac

          # Create tarballs
          (cd output && tar -cf ../$ARCHITECTURE.tar .)
          (cd output3 && tar -cf ../$ARCHITECTURE-core.tar .)
          if [[ "$ARCHITECTURE" =~ ^(x86_64|x86|aarch64|ppc64le)$ ]]; then
            (cd output2 && tar -cf ../$ARCHITECTURE-upx.tar .)
          fi

          # Rename x86 to i386 for consistency
          if [[ "$ARCHITECTURE" == "x86" ]]; then
            [ -f $ARCHITECTURE.tar ] && mv $ARCHITECTURE.tar i386.tar
            [ -f $ARCHITECTURE-core.tar ] && mv $ARCHITECTURE-core.tar i386-core.tar
            [ -f $ARCHITECTURE-upx.tar ] && mv $ARCHITECTURE-upx.tar i386-upx.tar
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ruri-cross-${{ matrix.arch }}
          path: |
            ./*.tar
          retention-days: 7

  release:
    name: Push Release (Cross-compiled)
    needs: [update, cross-build]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    if: |
      (github.event_name == 'push' && needs.update.outputs.release == 'true') ||
      startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Download All Build
        uses: actions/download-artifact@v4
        with:
          path: ./all

      - name: Move all .tar files
        run: |
          find ./all -type f -name "*.tar" -exec mv {} ./ \;
          # Upload only when file > 50kb
          for file in ./*.tar; do
            if [ ! -s "$file" ] || [ $(stat -c%s "$file") -lt 51200 ]; then
              echo "Removing $file as it is smaller than 50kb"
              rm "$file"
            fi
          done

      - name: Release
        uses: softprops/action-gh-release@v2.2.2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.update.outputs.version }}
          name: ${{ needs.update.outputs.release_name }} (Cross-compiled)
          body: |
            This is ruri binary release built with musl-cross-make cross-compilation.
            NOTE:
            *-upx means the binary is upx compressed.
            *-core means the binary is built without libseccomp and libcap, and with .rurienv disabled.
            ruri use musl as libc to build by default, for smaller binary size and better security.
            Build time: ${{ needs.update.outputs.build_time }}
            
            **Build method:** True cross-compilation using musl-cross-make toolchains
          files: |
            *.tar
