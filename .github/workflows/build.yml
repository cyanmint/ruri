name: Build release

on:
  workflow_dispatch:
  push:
    branches: [ "main" ]
    paths:
      - 'src/**'
      - 'build/**'
      - 'build.c'
      - '.github/**'
    tags:
      - "v*"
  pull_request:

jobs:
  update:
    name: Fetch Latest Version
    runs-on: ubuntu-latest
    outputs:
      release: ${{ steps.fetch_version.outputs.release }}
      version: ${{ steps.fetch_version.outputs.version }}
      release_name: ${{ steps.fetch_version.outputs.release_name }}
      build_time: ${{ steps.fetch_version.outputs.build_time }}
    steps:
      - name: fetch latest version
        id: fetch_version
        run: |
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref_type }}" == "tag" ]]; then
            version="${{ github.ref_name }}"
            release_name="ruri ${{ github.ref_name }} Release"
          else
            response=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -L "https://api.github.com/repos/${{ github.repository }}/releases/latest")
            version=$(echo "$response" | jq -r .tag_name)
            release_name=$(echo "$response" | jq -r .name)
          fi

          if [[ -n "$version" && "$version" != "null" && -n "$release_name" && "$release_name" != "null" ]]; then
            echo "release=true" >> $GITHUB_OUTPUT
          else
            echo "release=false" >> $GITHUB_OUTPUT
          fi

          build_time="UTC $(TZ=UTC date '+%Y%m%d%H%M')"
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "release_name=$release_name" >> $GITHUB_OUTPUT
          echo "build_time=$build_time" >> $GITHUB_OUTPUT

  build-arch:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    strategy:
      fail-fast: false  # Allow other architectures to continue even if one fails
      matrix:
        include:
          - arch: x86_64
            alpine_arch: x86_64
          - arch: x86
            alpine_arch: x86
          - arch: aarch64
            alpine_arch: aarch64
          - arch: armhf
            alpine_arch: armhf
          - arch: armv7
            alpine_arch: armv7
          - arch: ppc64le
            alpine_arch: ppc64le
          - arch: riscv64
            alpine_arch: riscv64
          - arch: s390x
            alpine_arch: s390x
    env:
      ARCHITECTURE: ${{ matrix.arch }}
      ALPINE_ARCH: ${{ matrix.alpine_arch }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU for multi-arch
        uses: docker/setup-qemu-action@v3

      - name: Build for ${{ matrix.arch }} using Alpine Docker
        shell: bash
        run: |
          # Map architecture names for Alpine
          case "$ALPINE_ARCH" in
            x86)
              DOCKER_ARCH="386"
              ;;
            x86_64)
              DOCKER_ARCH="amd64"
              ;;
            aarch64)
              DOCKER_ARCH="arm64"
              ;;
            armv7|armhf)
              DOCKER_ARCH="arm/v7"
              ;;
            ppc64le)
              DOCKER_ARCH="ppc64le"
              ;;
            riscv64)
              DOCKER_ARCH="riscv64"
              ;;
            s390x)
              DOCKER_ARCH="s390x"
              ;;
          esac

          # Run build in Alpine container for the target architecture
          docker run --rm --platform linux/$DOCKER_ARCH \
            -v "$GITHUB_WORKSPACE:/workspace" \
            -w /workspace \
            alpine:latest \
            sh -c '
              set -e
              
              # Install build dependencies
              apk add --no-cache make clang git libseccomp-dev libseccomp-static \
                libcap-static libcap-dev upx || true
              
              # Create output directories
              mkdir -p output output2 output3
              
              # Build fakepid library
              cd src/fakepid
              CC=clang make clean
              CC=clang make
              cd ../..
              
              # Build ruri
              clang build.c -o build-ruri
              ./build-ruri -s -f
              
              cp ruri output/ruri
              cp LICENSE output/LICENSE
              
              cp ruri output2/ruri
              cp LICENSE output2/LICENSE
              
              ./build-ruri -s -c -f
              cp ruri output3/ruri
              cp LICENSE output3/LICENSE
              
              # UPX compression for supported architectures
              case "'$ARCHITECTURE'" in
                x86_64|x86|aarch64|armhf|armv7|ppc64le)
                  if command -v upx >/dev/null 2>&1; then
                    upx --best output2/ruri || true
                    upx --best output3/ruri || true
                  fi
                  ;;
              esac
            '

          # Create tarballs
          (cd output && tar -cf ../$ARCHITECTURE.tar .)
          (cd output3 && tar -cf ../$ARCHITECTURE-core.tar .)
          if [[ "$ARCHITECTURE" =~ ^(x86_64|x86|aarch64|armhf|armv7|ppc64le)$ ]]; then
            (cd output2 && tar -cf ../$ARCHITECTURE-upx.tar .)
          fi

          # Rename x86 to i386 for consistency
          if [[ "$ARCHITECTURE" == "x86" ]]; then
            [ -f $ARCHITECTURE.tar ] && mv $ARCHITECTURE.tar i386.tar
            [ -f $ARCHITECTURE-core.tar ] && mv $ARCHITECTURE-core.tar i386-core.tar
            [ -f $ARCHITECTURE-upx.tar ] && mv $ARCHITECTURE-upx.tar i386-upx.tar
          fi

      - name: Upload artifacts
        if: true
        uses: actions/upload-artifact@v4
        with:
          name: ruri-${{ matrix.arch }}
          path: |
            ./*.tar
          retention-days: 7

  release:
    name: Push Release
    needs: [update,  build-arch]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    if: |
      (github.event_name == 'push' && needs.update.outputs.release == 'true') ||
      startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Download All Build
        uses: actions/download-artifact@v4
        with:
          path: ./all

      - name: Move all .tar files
        run: |
          find ./all -type f -name "*.tar" -exec mv {} ./ \;
          # Upload only when file > 50kb
          for file in ./*.tar; do
            if [ ! -s "$file" ] || [ $(stat -c%s "$file") -lt 51200 ]; then
              echo "Removing $file as it is smaller than 50kb"
              rm "$file"
            fi
          done

      - name: Release
        uses: softprops/action-gh-release@v2.2.2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.update.outputs.version }}
          name: ${{ needs.update.outputs.release_name }}
          body: |
            This is ruri binary release.
            NOTE:
            *-upx means the binary is upx compressed.
            *-core means the binary is built without libseccomp and libcap, and with .rurienv disabled.
            ruri use musl as libc to build by default (in alpine container), for smaller binary size and better security.
            Build time: ${{ needs.update.outputs.build_time }}
          files: |
            *.tar
